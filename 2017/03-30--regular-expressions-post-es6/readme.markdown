<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/regular-expressions-post-es6">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/regular-expressions-post-es6"><div><img src="https://i.imgur.com/9OLawFo.jpg" alt="Regular Expressions in a post-ES6 world"></div></a>

<h1>Regular Expressions in a post-ES6 world</h1>

<p><kbd>es6</kbd> <kbd>unicode</kbd> <kbd>regular-expressions</kbd></p>

<blockquote><p>In this article we&#x2019;ll take a look at regular expressions improvements in and after ES6. We&#x2019;ll discuss the <code>/y</code>, <code>/u</code>, and <code>/s</code> flags, named capture groups, unicode property escapes, lookbehind assertions, and <code>String#matchAll</code>.</p>
</blockquote>

<div><p>In this article we&#x2019;ll take a look at regular expressions in and after ES6. There&#x2019;s a couple of regular expressions flags which were introduced in ES6: the <code class="md-code md-code-inline">/y</code> or sticky flag, and the <code class="md-code md-code-inline">/u</code> or Unicode flag. Then we&#x2019;ll discuss five proposals which are making their way through the <a href="https://ponyfoo.com/articles/standard" aria-label="The JavaScript Standard on Pony Foo">ECMAScript specification development process</a> at TC39.</p></div>

<blockquote></blockquote>

<div><h1 id="sticky-matching-flag-y">Sticky Matching Flag <code class="md-code md-code-inline">/y</code></h1> <p>The sticky matching <code class="md-code md-code-inline">y</code> flag introduced in ES6 is similar to the global <code class="md-code md-code-inline">g</code> flag. Like global regular expressions, sticky ones are typically used to match several times until the input string is exhausted. Sticky regular expressions move <code class="md-code md-code-inline">lastIndex</code> to the position after the last match, just like global regular expressions. The only difference is that a sticky regular expression must start matching where the previous match left off, unlike global regular expressions that move onto the rest of the input string when the regular expression goes unmatched at any given position.</p> <p>The following example illustrates the difference between the two. Given an input string like <code class="md-code md-code-inline">&apos;haha haha haha&apos;</code> and the <code class="md-code md-code-inline">/ha/</code> regular expression, the global flag will match every occurrence of <code class="md-code md-code-inline">&apos;ha&apos;</code>, while the sticky flag will only match the first two, since the third occurrence doesn&#x2019;t match starting at index <code class="md-code md-code-inline">4</code>, but rather at index <code class="md-code md-code-inline">5</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">matcher</span><span class="md-code-params">(regex, input)</span> </span>{
  <span class="md-code-keyword">return</span> () =&gt; {
    <span class="md-code-keyword">const</span> match = regex.exec(input)
    <span class="md-code-keyword">const</span> lastIndex = regex.lastIndex
    <span class="md-code-keyword">return</span> { lastIndex, match }
  }
}
<span class="md-code-keyword">const</span> input = <span class="md-code-string">&apos;haha haha haha&apos;</span>
<span class="md-code-keyword">const</span> nextGlobal = matcher(<span class="md-code-regexp">/ha/g</span>, input)
<span class="md-code-built_in">console</span>.log(nextGlobal()) <span class="md-code-comment">// &lt;- { lastIndex: 2, match: [&apos;ha&apos;] }</span>
<span class="md-code-built_in">console</span>.log(nextGlobal()) <span class="md-code-comment">// &lt;- { lastIndex: 4, match: [&apos;ha&apos;] }</span>
<span class="md-code-built_in">console</span>.log(nextGlobal()) <span class="md-code-comment">// &lt;- { lastIndex: 7, match: [&apos;ha&apos;] }</span>
<span class="md-code-keyword">const</span> nextSticky = matcher(<span class="md-code-regexp">/ha/y</span>, input)
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 2, match: [&apos;ha&apos;] }</span>
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 4, match: [&apos;ha&apos;] }</span>
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 0, match: null }</span>
</code></pre> <p>We can verify that the sticky matcher would work if we forcefully moved <code class="md-code md-code-inline">lastIndex</code> with the next piece of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rsticky = <span class="md-code-regexp">/ha/y</span>
<span class="md-code-keyword">const</span> nextSticky = matcher(rsticky, input)
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 2, match: [&apos;ha&apos;] }</span>
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 4, match: [&apos;ha&apos;] }</span>
rsticky.lastIndex = <span class="md-code-number">5</span>
<span class="md-code-built_in">console</span>.log(nextSticky()) <span class="md-code-comment">// &lt;- { lastIndex: 7, match: [&apos;ha&apos;] }</span>
</code></pre> <p>Sticky matching was added to JavaScript as a way of improving the performance of lexical analyzers in compilers, which heavily rely on regular expressions.</p></div>

<div><h1 id="unicode-flag-u">Unicode Flag <code class="md-code md-code-inline">/u</code></h1> <p>ES6 also introduced a <code class="md-code md-code-inline">u</code> flag. The <code class="md-code md-code-inline">u</code> stands for Unicode, but this flag can also be thought of as a more strict version of regular expressions.</p> <p>Without the <code class="md-code md-code-inline">u</code> flag, the following snippet has a regular expression containing an <code class="md-code md-code-inline">&apos;a&apos;</code> character literal that was unnecessarily escaped.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/\a/.test(<span class="md-code-string">&apos;ab&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Using an escape sequence for an unreserved character such as <code class="md-code md-code-inline">a</code> in a regular expression with the <code class="md-code md-code-inline">u</code> flag results in an error, as shown in the following bit of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/\a/u.test(<span class="md-code-string">&apos;ab&apos;</span>)
<span class="md-code-comment">// &lt;- SyntaxError: Invalid regular expression: /\a/: Invalid escape</span>
</code></pre> <p>The following example attempts to embed the horse emoji in a regular expression by way of the <code class="md-code md-code-inline">\u{1f40e}</code> notation which ES6 introduced for strings like <code class="md-code md-code-inline">&apos;\u{1f40e}&apos;</code>, but the regular expression fails to match against the horse emoji. Without the <code class="md-code md-code-inline">u</code> flag, the <code class="md-code md-code-inline">\u{&#x2026;}</code> pattern is interpreted as having an unnecessarily escaped <code class="md-code md-code-inline">u</code> character followed by the rest of the sequence.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/\u{<span class="md-code-number">1</span>f40e}/.test(<span class="md-code-string">&apos;&#x1F40E;&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
/\u{<span class="md-code-number">1</span>f40e}/.test(<span class="md-code-string">&apos;u{1f40e}&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>The <code class="md-code md-code-inline">u</code> flag introduces support for Unicode code point escapes, like the <code class="md-code md-code-inline">\u{1f40e}</code> horse emoji, within regular expressions.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/\u{<span class="md-code-number">1</span>f40e}/u.test(<span class="md-code-string">&apos;&#x1F40E;&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Without the <code class="md-code md-code-inline">u</code> flag, the <code class="md-code md-code-inline">.</code> pattern matches any BMP symbol except for line terminators. The following example shows <code class="md-code md-code-inline">U+1D11E MUSICAL SYMBOL G CLEF</code>, an astral symbol that wouldn&#x2019;t match the dot pattern in plain regular expressions.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rdot = <span class="md-code-regexp">/^.$/</span>
rdot.test(<span class="md-code-string">&apos;a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rdot.test(<span class="md-code-string">&apos;\n&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
rdot.test(<span class="md-code-string">&apos;\u{1d11e}&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>When using the <code class="md-code md-code-inline">u</code> flag, Unicode symbols that aren&#x2019;t on the BMP are matched as well. The next snippet shows how the astral symbol matches when the flag is set.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rdot = <span class="md-code-regexp">/^.$/u</span>
rdot.test(<span class="md-code-string">&apos;a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rdot.test(<span class="md-code-string">&apos;\n&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
rdot.test(<span class="md-code-string">&apos;\u{1d11e}&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>When the <code class="md-code md-code-inline">u</code> flag is set, similar Unicode awareness improvements can be found in quantifiers and character classes, both of which treat each Unicode code point as a single symbol, instead of matching on the first code unit only. Insensitive case matching with the <code class="md-code md-code-inline">i</code> flag performs Unicode case folding when the <code class="md-code md-code-inline">u</code> flag is set as well, which is used to normalize code points in both the input string and the regular expression.</p> <p>For more details around the <code class="md-code md-code-inline">u</code> flag in regular expressions, read <a href="https://mjavascript.com/out/regexp-unicode" target="_blank" rel="noopener noreferrer" aria-label="Unicode-aware regular expressions in ECMAScript 6 by Mathias Bynens">this piece by Mathias Bynens</a>.</p> <h1 id="named-capture-groups">Named Capture Groups</h1> <p>Up until now, JavaScript regular expressions could group matches in numbered capturing groups and non-capturing groups. In the next snippet we&#x2019;re using a couple of groups to extract a key and value from an input string containing a key value pair delimited by <code class="md-code md-code-inline">&apos;=&apos;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">parseKeyValuePair</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rattribute = <span class="md-code-regexp">/([a-z]+)=([a-z]+)/</span>
  <span class="md-code-keyword">const</span> [, key, value] = rattribute.exec(input)
  <span class="md-code-keyword">return</span> { key, value }
}
parseKeyValuePair(<span class="md-code-string">&apos;strong=true&apos;</span>)
<span class="md-code-comment">// &lt;- { key: &apos;strong&apos;, value: &apos;true&apos; }</span>
</code></pre> <p>There&#x2019;s also non-capturing groups, which are discarded and not present in the final result, but are still useful for matching. The following example supports input with key value pairs delimited by <code class="md-code md-code-inline">&apos; is &apos;</code> in addition to <code class="md-code md-code-inline">&apos;=&apos;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">parseKeyValuePair</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rattribute = <span class="md-code-regexp">/([a-z]+)(?:=|\sis\s)([a-z]+)/</span>
  <span class="md-code-keyword">const</span> [, key, value] = rattribute.exec(input)
  <span class="md-code-keyword">return</span> { key, value }
}
parseKeyValuePair(<span class="md-code-string">&apos;strong is true&apos;</span>) <span class="md-code-comment">// &lt;- { key: &apos;strong&apos;, value: &apos;true&apos; }</span>
parseKeyValuePair(<span class="md-code-string">&apos;flexible=too&apos;</span>) <span class="md-code-comment">// &lt;- { key: &apos;flexible&apos;, value: &apos;too&apos; }</span>
</code></pre> <p>While array destructuring in the previous example hid our code&#x2019;s reliance on magic array indices, the fact remains that matches are placed in an ordered array regardless. The <a href="https://mjavascript.com/out/regexp-named-groups" target="_blank" rel="noopener noreferrer" aria-label="Named capture groups proposal document">named capture groups proposal</a> <em>(in stage 3 at the time of this writing)</em> adds syntax like <code class="md-code md-code-inline">(?&lt;groupName&gt;)</code> where we can name capturing groups, which are then returned in a <code class="md-code md-code-inline">groups</code> property of the returned match object. The <code class="md-code md-code-inline">groups</code> property can then be destructured from the resulting object when calling <code class="md-code md-code-inline">RegExp#exec</code> or <code class="md-code md-code-inline">String#match</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">parseKeyValuePair</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rattribute = <span class="md-code-regexp">/(?&lt;key&gt;[a-z]+)(?:=|\sis\s)(?&lt;value&gt;[a-z]+)/u</span>
  <span class="md-code-keyword">const</span> { groups } = rattribute.exec(input)
  <span class="md-code-keyword">return</span> groups
}
parseKeyValuePair(<span class="md-code-string">&apos;strong=true&apos;</span>) <span class="md-code-comment">// &lt;- { key: &apos;strong&apos;, value: &apos;true&apos; }</span>
parseKeyValuePair(<span class="md-code-string">&apos;flexible=too&apos;</span>) <span class="md-code-comment">// &lt;- { key: &apos;flexible&apos;, value: &apos;too&apos; }</span>
</code></pre> <p>JavaScript regular expressions support backreferences, where captured groups can be reused to look for duplicates. The following snippet uses a backreference for the first capturing group to identify cases where a username is the same as a password in a piece of <code class="md-code md-code-inline">&apos;user:password&apos;</code> input.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">hasSameUserAndPassword</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rduplicate = <span class="md-code-regexp">/([^:]+):\1/</span>
  <span class="md-code-keyword">return</span> rduplicate.exec(input) !== <span class="md-code-literal">null</span>
}
hasSameUserAndPassword(<span class="md-code-string">&apos;root:root&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
hasSameUserAndPassword(<span class="md-code-string">&apos;root:pF6GGlyPhoy1!9i&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>The named capture groups proposal adds support for named backreferences, which refer back to named groups.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">hasSameUserAndPassword</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rduplicate = <span class="md-code-regexp">/(?&lt;user&gt;[^:]+):\k&lt;user&gt;/u</span>
  <span class="md-code-keyword">return</span> rduplicate.exec(input) !== <span class="md-code-literal">null</span>
}
hasSameUserAndPassword(<span class="md-code-string">&apos;root:root&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
hasSameUserAndPassword(<span class="md-code-string">&apos;root:pF6GGlyPhoy1!9i&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>The <code class="md-code md-code-inline">\k&lt;groupName&gt;</code> reference can be used in tandem with numbered references, but the latter are better avoided when already using named references.</p> <p>Lastly, named groups can be referenced from the replacement passed to <code class="md-code md-code-inline">String#replace</code>. In the next code snippet we use <code class="md-code md-code-inline">String#replace</code> and named groups to change an American date string to use Hungarian formatting.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">americanDateToHungarianFormat</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> ramerican = <span class="md-code-regexp">/(?&lt;month&gt;\d{2})\/(?&lt;day&gt;\d{2})\/(?&lt;year&gt;\d{4})/u</span>
  <span class="md-code-keyword">const</span> hungarian = input.replace(ramerican, <span class="md-code-string">&apos;$&lt;year&gt;-$&lt;month&gt;-$&lt;day&gt;&apos;</span>)
  <span class="md-code-keyword">return</span> hungarian
}
americanDateToHungarianFormat(<span class="md-code-string">&apos;06/09/1988&apos;</span>) <span class="md-code-comment">// &lt;- &apos;1988-09-06&apos;</span>
</code></pre> <p>If the second argument to <code class="md-code md-code-inline">String#replace</code> is a function, then the named groups can be accessed via a new parameter called <code class="md-code md-code-inline">groups</code> that is at the end of the parameter list. The signature for that function now is <code class="md-code md-code-inline">(match, ...captures, groups)</code>. In the following example, note how we&#x2019;re using a template literal that&#x2019;s similar to the replacement string found in the last example. The fact that replacement strings follow a <code class="md-code md-code-inline">$&lt;groupName&gt;</code> syntax as opposed to a <code class="md-code md-code-inline">${groupName}</code> syntax means we can name groups in replacement strings without having to resort to escape codes if we were using template literals.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">americanDateToHungarianFormat</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> ramerican = <span class="md-code-regexp">/(?&lt;month&gt;\d{2})\/(?&lt;day&gt;\d{2})\/(?&lt;year&gt;\d{4})/u</span>
  <span class="md-code-keyword">const</span> hungarian = input.replace(ramerican, (match, capture1, capture2, capture3, groups) =&gt; {
    <span class="md-code-keyword">const</span> { month, day, year } = groups
    <span class="md-code-keyword">return</span> `${ year }-${ month }-${ day }`
  })
  <span class="md-code-keyword">return</span> hungarian
}
americanDateToHungarianFormat(<span class="md-code-string">&apos;06/09/1988&apos;</span>) <span class="md-code-comment">// &lt;- &apos;1988-09-06&apos;</span>
</code></pre> <h1 id="unicode-property-escapes">Unicode Property Escapes</h1> <p>The proposed <a href="https://mjavascript.com/out/unicode-property-escapes" target="_blank" rel="noopener noreferrer" aria-label="Unicode property escapes proposal document">Unicode property escapes</a> <em>(currently in stage 3)</em> are a new kind of escape sequence that&#x2019;s available in regular expressions marked with the <code class="md-code md-code-inline">u</code> flag. This proposal adds a escape in the form of <code class="md-code md-code-inline">\p{LoneUnicodePropertyNameOrValue}</code> for binary Unicode properties and <code class="md-code md-code-inline">\p{UnicodePropertyName=UnicodePropertyValue}</code> for non-binary Unicode properties. In addition, <code class="md-code md-code-inline">\P</code> is the negated version of a <code class="md-code md-code-inline">\p</code> escape sequence.</p> <p>The Unicode standard defines properties for every symbol. Armed with these properties, one may make advanced queries about Unicode characters. For example, symbols in the greek alphabet have a <code class="md-code md-code-inline">Script</code> property set to <code class="md-code md-code-inline">Greek</code>. We could use the new escapes to match any greek Unicode symbol.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">isGreekSymbol</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rgreek = <span class="md-code-regexp">/^\p{Script=Greek}$/u</span>
  <span class="md-code-keyword">return</span> rgreek.test(input)
}
isGreekSymbol(<span class="md-code-string">&apos;&#x3C0;&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Or, using <code class="md-code md-code-inline">\P</code>, we could match non-greek Unicode symbols.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">isNonGreekSymbol</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rgreek = <span class="md-code-regexp">/^\P{Script=Greek}$/u</span>
  <span class="md-code-keyword">return</span> rgreek.test(input)
}
isNonGreekSymbol(<span class="md-code-string">&apos;&#x3C0;&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>When we need to match every Unicode decimal number symbol, and not just <code class="md-code md-code-inline">[0-9]</code> like <code class="md-code md-code-inline">\d</code> does, we could use <code class="md-code md-code-inline">\p{Decimal_Number}</code> as shown next.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">isDecimalNumber</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rdigits = <span class="md-code-regexp">/^\p{Decimal_Number}+$/u</span>
  <span class="md-code-keyword">return</span> rdigits.test(input)
}
isDecimalNumber(<span class="md-code-string">&apos;&#x1D7CF;&#x1D7D0;&#x1D7D1;&#x1D7DC;&#x1D7DD;&#x1D7DE;&#x1D7E9;&#x1D7EA;&#x1D7EB;&#x1D7EC;&#x1D7ED;&#x1D7EE;&#x1D7EF;&#x1D7FA;&#x1D7FB;&#x1D7FC;&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Linked next is a full list of <a href="https://mjavascript.com/out/unicode-property-list" target="_blank" rel="noopener noreferrer" aria-label="Exhaustive overview of supported Unicode properties and values">supported Unicode properties and values</a>.</p> <h1 id="lookbehind-assertions">Lookbehind Assertions</h1> <p>JavaScript has had positive lookahead assertions for a long time. That feature allows us to match an expression but only if it&#x2019;s followed by another expression. These assertions are expressed as <code class="md-code md-code-inline">(?=&#x2026;)</code>. Regardless of whether a lookahead assertion matches, the results of that match are discarded and no characters of the input string are consumed.</p> <p>The following example uses a positive lookahead to test whether an input string has a sequence of letters followed by <code class="md-code md-code-inline">.js</code>, in which case it returns the filename without the <code class="md-code md-code-inline">.js</code> part.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getJavaScriptFilename</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rfile = <span class="md-code-regexp">/^(?&lt;filename&gt;[a-z]+)(?=\.js)\.[a-z]+$/u</span>
  <span class="md-code-keyword">const</span> match = rfile.exec(input)
  <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
    <span class="md-code-keyword">return</span> <span class="md-code-literal">null</span>
  }
  <span class="md-code-keyword">return</span> match.groups.filename
}
getJavaScriptFilename(<span class="md-code-string">&apos;index.js&apos;</span>) <span class="md-code-comment">// &lt;- &apos;index&apos;</span>
getJavaScriptFilename(<span class="md-code-string">&apos;index.php&apos;</span>) <span class="md-code-comment">// &lt;- null</span>
</code></pre> <p>There are also negative lookahead assertions, which are expressed as <code class="md-code md-code-inline">(?!&#x2026;)</code> as opposed to <code class="md-code md-code-inline">(?=&#x2026;)</code> for positive lookaheads. In this case, the assertion succeeds only if the lookahead expression isn&#x2019;t matched. The next bit of code uses a negative lookahead and we can observe how the results are flipped: now any expression other than <code class="md-code md-code-inline">&apos;.js&apos;</code> results in a passed assertion.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getNonJavaScriptFilename</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rfile = <span class="md-code-regexp">/^(?&lt;filename&gt;[a-z]+)(?!\.js)\.[a-z]+$/u</span>
  <span class="md-code-keyword">const</span> match = rfile.exec(input)
  <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
    <span class="md-code-keyword">return</span> <span class="md-code-literal">null</span>
  }
  <span class="md-code-keyword">return</span> match.groups.filename
}
getNonJavaScriptFilename(<span class="md-code-string">&apos;index.js&apos;</span>) <span class="md-code-comment">// &lt;- null</span>
getNonJavaScriptFilename(<span class="md-code-string">&apos;index.php&apos;</span>) <span class="md-code-comment">// &lt;- &apos;index&apos;</span>
</code></pre> <p>The <a href="https://mjavascript.com/out/regexp-lookbehind" target="_blank" rel="noopener noreferrer" aria-label="Lookbehind assertions proposal document">proposal for lookbehind</a> <em>(stage 3)</em> introduces positive and negative lookbehind assertions, denoted with <code class="md-code md-code-inline">(?&lt;=&#x2026;)</code> and <code class="md-code md-code-inline">(?&lt;!&#x2026;)</code> respectively. These assertions can be used to ensure a pattern we want to match is or isn&#x2019;t preceded by another given pattern. The following snippet uses a positive lookbehind to match the digits in dollar amounts, but not for amounts in euros.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getDollarAmount</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rdollars = <span class="md-code-regexp">/^(?&lt;=\$)(?&lt;amount&gt;\d+(?:\.\d+)?)$/u</span>
  <span class="md-code-keyword">const</span> match = rdollars.exec(input)
  <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
    <span class="md-code-keyword">return</span> <span class="md-code-literal">null</span>
  }
  <span class="md-code-keyword">return</span> match.groups.amount
}
getDollarAmount(<span class="md-code-string">&apos;$12.34&apos;</span>) <span class="md-code-comment">// &lt;- &apos;12.34&apos;</span>
getDollarAmount(<span class="md-code-string">&apos;&#x20AC;12.34&apos;</span>) <span class="md-code-comment">// &lt;- null</span>
</code></pre> <p>On the other hand, a negative lookbehind could be used to match numbers that aren&#x2019;t preceded by a dollar sign.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getNonDollarAmount</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rnumbers = <span class="md-code-regexp">/^(?&lt;!\$)(?&lt;amount&gt;\d+(?:\.\d+)?)$/u</span>
  <span class="md-code-keyword">const</span> match = rnumbers.exec(input)
  <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
    <span class="md-code-keyword">return</span> <span class="md-code-literal">null</span>
  }
  <span class="md-code-keyword">return</span> match.groups.amount
}
getNonDollarAmount(<span class="md-code-string">&apos;$12.34&apos;</span>) <span class="md-code-comment">// &lt;- null</span>
getNonDollarAmount(<span class="md-code-string">&apos;&#x20AC;12.34&apos;</span>) <span class="md-code-comment">// &lt;- &apos;12.34&apos;</span>
</code></pre> <h1 id="a-new-s-dotall-flag">A New <code class="md-code md-code-inline">/s</code> <em>(<code class="md-code md-code-inline">dotAll</code>)</em> Flag</h1> <p>When using the <code class="md-code md-code-inline">.</code> pattern, we typically expect to match every single character. In JavaScript, however, a <code class="md-code md-code-inline">.</code> expression doesn&#x2019;t match astral characters <em>(which can be fixed by adding the <code class="md-code md-code-inline">u</code> flag)</em> nor line terminators.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rcharacter = <span class="md-code-regexp">/^.$/</span>
rcharacter.test(<span class="md-code-string">&apos;a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\t&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\n&apos;</span>) <span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>This sometimes drives developers to write other kinds of expressions to synthesize a pattern that matches any character. The expression in the next bit of code matches any character that&#x2019;s either a whitespace character or a non-whitespace character, delivering the behavior we&#x2019;d expect from the <code class="md-code md-code-inline">.</code> pattern matcher.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rcharacter = <span class="md-code-regexp">/^[\s\S]$/</span>
rcharacter.test(<span class="md-code-string">&apos;a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\t&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\n&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>The <a href="https://mjavascript.com/out/regexp-dotall" target="_blank" rel="noopener noreferrer" aria-label="&apos;dotAll&apos; flag proposal document"><code class="md-code md-code-inline">dotAll</code> proposal</a> <em>(stage 3)</em> adds an <code class="md-code md-code-inline">s</code> flag which changes the behavior of <code class="md-code md-code-inline">.</code> in JavaScript regular expressions to match any single character.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rcharacter = <span class="md-code-regexp">/^.$/</span>s
rcharacter.test(<span class="md-code-string">&apos;a&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\t&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
rcharacter.test(<span class="md-code-string">&apos;\n&apos;</span>) <span class="md-code-comment">// &lt;- true</span>
</code></pre> <h1 id="string-matchall"><code class="md-code md-code-inline">String#matchAll</code></h1> <p>Often, when we have a regular expression with a global or sticky flag, we want to iterate over the set of captured groups for each match. Currently, it can be a bit of a hassle to produce the list of matches: we need to collect the captured groups using <code class="md-code md-code-inline">String#match</code> or <code class="md-code md-code-inline">RegExp#exec</code> in a loop, until the regular expression doesn&#x2019;t match the input starting at the <code class="md-code md-code-inline">lastIndex</code> position property. In the following piece of code, the <code class="md-code md-code-inline">parseAttributes</code> generator function does just that for a given regular expression.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">parseAttributes</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rattributes = <span class="md-code-regexp">/(\w+)=&quot;([^&quot;]+)&quot;\s/ig</span>
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">const</span> match = rattributes.exec(input)
    <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
      <span class="md-code-keyword">break</span>
    }
    <span class="md-code-keyword">const</span> [ , key, value] = match
    <span class="md-code-keyword">yield</span> [key, value]
  }
}
<span class="md-code-keyword">const</span> html = <span class="md-code-string">&apos;&lt;input type=&quot;email&quot; placeholder=&quot;hello@mjavascript.com&quot; /&gt;&apos;</span>
<span class="md-code-built_in">console</span>.log(...parseAttributes(html))
<span class="md-code-comment">// &lt;- [&apos;type&apos;, &apos;email&apos;] [&apos;placeholder&apos;, &apos;hello@mjavascript.com&apos;]</span>
</code></pre> <p>One problem with this approach is that it&#x2019;s tailor-made for our regular expression and its capturing groups. We could fix that issue by creating a <code class="md-code md-code-inline">matchAll</code> generator which is only concerned about looping over matches and collecting sets of captured groups, as shown in the following snippet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">matchAll</span><span class="md-code-params">(regex, input)</span> </span>{
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">const</span> match = regex.exec(input)
    <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
      <span class="md-code-keyword">break</span>
    }
    <span class="md-code-keyword">const</span> [ , ...captures] = match
    <span class="md-code-keyword">yield</span> captures
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">parseAttributes</span><span class="md-code-params">(input)</span> </span>{
  <span class="md-code-keyword">const</span> rattributes = <span class="md-code-regexp">/(\w+)=&quot;([^&quot;]+)&quot;\s/ig</span>
  <span class="md-code-keyword">yield</span>* matchAll(rattributes, input)
}
<span class="md-code-keyword">const</span> html = <span class="md-code-string">&apos;&lt;input type=&quot;email&quot; placeholder=&quot;hello@mjavascript.com&quot; /&gt;&apos;</span>
<span class="md-code-built_in">console</span>.log(...parseAttributes(html))
<span class="md-code-comment">// &lt;- [&apos;type&apos;, &apos;email&apos;] [&apos;placeholder&apos;, &apos;hello@mjavascript.com&apos;]</span>
</code></pre> <p>A bigger source of confusion is that <code class="md-code md-code-inline">rattributes</code> mutates its <code class="md-code md-code-inline">lastIndex</code> property on each call to <code class="md-code md-code-inline">RegExp#exec</code>, which is how it can track the position after the last match. When there are no matches left, <code class="md-code md-code-inline">lastIndex</code> is reset back to <code class="md-code md-code-inline">0</code>. A problem arises when we don&#x2019;t iterate over all possible matches for a piece of input in one go &#x2013; which would reset <code class="md-code md-code-inline">lastIndex</code> to <code class="md-code md-code-inline">0</code> &#x2013; and then we use the regular expression on a second piece of input, obtaining unexpected results.</p> <p>While it looks like our <code class="md-code md-code-inline">matchAll</code> implementation wouldn&#x2019;t fall victim of this given it loops over all matches, it&#x2019;s be possible to iterate over the generator by hand, meaning that we&#x2019;d run into trouble if we reused the same regular expression, as shown in the next bit of code. Note how the second matcher should report <code class="md-code md-code-inline">[&apos;type&apos;, &apos;text&apos;]</code> but instead starts at an index much further ahead than <code class="md-code md-code-inline">0</code>, even misreporting the <code class="md-code md-code-inline">&apos;placeholder&apos;</code> key as <code class="md-code md-code-inline">&apos;laceholder&apos;</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rattributes = <span class="md-code-regexp">/(\w+)=&quot;([^&quot;]+)&quot;\s/ig</span>
<span class="md-code-keyword">const</span> email = <span class="md-code-string">&apos;&lt;input type=&quot;email&quot; placeholder=&quot;hello@mjavascript.com&quot; /&gt;&apos;</span>
<span class="md-code-keyword">const</span> emailMatcher = matchAll(rattributes, email)
<span class="md-code-keyword">const</span> address = <span class="md-code-string">&apos;&lt;input type=&quot;text&quot; placeholder=&quot;Enter your business address&quot; /&gt;&apos;</span>
<span class="md-code-keyword">const</span> addressMatcher = matchAll(rattributes, address)
<span class="md-code-built_in">console</span>.log(emailMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;type&apos;, &apos;email&apos;]</span>
<span class="md-code-built_in">console</span>.log(addressMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;laceholder&apos;, &apos;Enter your business address&apos;]</span>
</code></pre> <p>One solution would be to change <code class="md-code md-code-inline">matchAll</code> so that <code class="md-code md-code-inline">lastIndex</code> is always <code class="md-code md-code-inline">0</code> when we yield back to the consumer code, while keeping track of <code class="md-code md-code-inline">lastIndex</code> internally so that we can pick up where we left off in each step of the sequence.</p> <p>The following piece of code shows that indeed, that&#x2019;d fix the problems we&#x2019;re observing. Reusable global regular expressions are often avoided for this very reason: so that we don&#x2019;t have to worry about resetting <code class="md-code md-code-inline">lastIndex</code> after every use.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">matchAll</span><span class="md-code-params">(regex, input)</span> </span>{
  <span class="md-code-keyword">let</span> lastIndex = <span class="md-code-number">0</span>
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    regex.lastIndex = lastIndex
    <span class="md-code-keyword">const</span> match = regex.exec(input)
    <span class="md-code-keyword">if</span> (match === <span class="md-code-literal">null</span>) {
      <span class="md-code-keyword">break</span>
    }
    lastIndex = regex.lastIndex
    regex.lastIndex = <span class="md-code-number">0</span>
    <span class="md-code-keyword">const</span> [ , ...captures] = match
    <span class="md-code-keyword">yield</span> captures
  }
}
<span class="md-code-keyword">const</span> rattributes = <span class="md-code-regexp">/(\w+)=&quot;([^&quot;]+)&quot;\s/ig</span>
<span class="md-code-keyword">const</span> email = <span class="md-code-string">&apos;&lt;input type=&quot;email&quot; placeholder=&quot;hello@mjavascript.com&quot; /&gt;&apos;</span>
<span class="md-code-keyword">const</span> emailMatcher = matchAll(rattributes, email)
<span class="md-code-keyword">const</span> address = <span class="md-code-string">&apos;&lt;input type=&quot;text&quot; placeholder=&quot;Enter your business address&quot; /&gt;&apos;</span>
<span class="md-code-keyword">const</span> addressMatcher = matchAll(rattributes, address)
<span class="md-code-built_in">console</span>.log(emailMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;type&apos;, &apos;email&apos;]</span>
<span class="md-code-built_in">console</span>.log(addressMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;type&apos;, &apos;text&apos;]</span>
<span class="md-code-built_in">console</span>.log(emailMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;placeholder&apos;, &apos;hello@mjavascript.com&apos;]</span>
<span class="md-code-built_in">console</span>.log(addressMatcher.next().value)
<span class="md-code-comment">// &lt;- [&apos;placeholder&apos;, &apos;Enter your business address&apos;]</span>
</code></pre> <p>The <a href="https://mjavascript.com/out/string-matchall" target="_blank" rel="noopener noreferrer" aria-label="String#matchAll proposal document"><code class="md-code md-code-inline">String#matchAll</code> proposal</a> <em>(in stage 1 at the time of this writing)</em> introduces a new method for the string prototype which would behave in a similar fashion as our <code class="md-code md-code-inline">matchAll</code> implementation, except the returned iterable is a sequence of <code class="md-code md-code-inline">match</code> object as opposed to just the <code class="md-code md-code-inline">captures</code> in the example above. Note that the <code class="md-code md-code-inline">String#matchAll</code> sequence contains entire <code class="md-code md-code-inline">match</code> objects, and not just numbered captures. This means we could access named captures through <code class="md-code md-code-inline">match.groups</code> for each <code class="md-code md-code-inline">match</code> in the sequence.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> rattributes = <span class="md-code-regexp">/(?&lt;key&gt;\w+)=&quot;(?&lt;value&gt;[^&quot;]+)&quot;\s/igu</span>
<span class="md-code-keyword">const</span> email = <span class="md-code-string">&apos;&lt;input type=&quot;email&quot; placeholder=&quot;hello@mjavascript.com&quot; /&gt;&apos;</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">const</span> { groups: { key, value } } of email.matchAll(rattributes)) {
  <span class="md-code-built_in">console</span>.log(`${ key }: ${ value }`)
}
<span class="md-code-comment">// &lt;- type: email</span>
<span class="md-code-comment">// &lt;- placeholder: hello@mjavascript.com</span>
</code></pre></div>
