<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/disguise-driven-testing-jest-mocks-in-depth"><div><img src="https://images.ponyfoo.com/uploads/1_y9LWWd156Ww8CAqZm0GD5Q-20b26a1d79804779aff192cf7b04a254.jpeg" alt="Disguise-Driven Testing: Jest Mocks in Depth"></div></a>

<h1>Disguise-Driven Testing: Jest Mocks in Depth</h1>

<p><kbd>testing</kbd> <kbd>jest</kbd></p>

<blockquote><p>Testing <em>can</em> be simple. In fact, it is simple. Well, it <em>is</em> simple until impurities slip in.</p> <p>Code that would be easy to test becomes a nightmare as soon as you get impure &#x2026;</p></blockquote>

<div><p>Testing <em>can</em> be simple. In fact, it is simple. Well, it <em>is</em> simple until impurities slip in.</p> <p>Code that would be easy to test becomes a nightmare as soon as you get impure data (like date checks) or complex external dependencies (such as DOM manipulations or large 3rd party libraries). The part that tends to frustrate developers most is when they have code that&#x2019;s easy to read, easy to write, but difficult to test. No one wants to spend more time on their tests than they do on their code.</p></div>

<blockquote></blockquote>

<div><p>Consider an example. Let&#x2019;s say you needed to write some code that checks to see if a given date is two weeks from today. If they date is far enough away, you get an empty string. If the date is less than two weeks away, you get an error message:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import moment from <span class="md-code-string">&apos;moment&apos;</span>;

export <span class="md-code-keyword">const</span> message = <span class="md-code-string">&apos;Date must be two weeks from now&apos;</span>

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">isAtLeastTwoWeeks</span><span class="md-code-params">(date)</span> </span>{
  <span class="md-code-keyword">const</span> isLater = moment(date).isAfter(moment().add(<span class="md-code-number">2</span>, <span class="md-code-string">&apos;weeks&apos;</span>));
  <span class="md-code-keyword">return</span> isLater ? <span class="md-code-string">&apos;&apos;</span> : message;
}
</code></pre> <p>That&#x2019;s pretty simple code. But how do you write a test for it? Things can get tricky fast.</p></div>

<div><p>Here&#x2019;s an even more basic example. You want to fetch some data from an API and display the first couple items:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getRecent</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> fetch(<span class="md-code-string">&apos;/albums&apos;</span>)
    .then(response =&gt; response.json())
    .then(albums =&gt; {
      <span class="md-code-keyword">return</span> albums
        .reverse()
        .slice(<span class="md-code-number">0</span>, <span class="md-code-number">2</span>)
        .map(({title}) =&gt; title);
    })
}
</code></pre> <p>Simple to read. Simple to understand. But how would you test it without hitting the live API?</p> <p>There&#x2019;s an unfortunate belief that testing is hard. Early in my career, I heard one developer estimate that it doubled development time. And he was arguing <em>for</em> testing, that it was worth the extra time. The problem is that most testing is easy. But testing impure functions can be very, very difficult.</p> <p>Fortunately, the <a href="https://medium.com/r/?url=https%3A%2F%2Fjestjs.io" target="_blank" rel="noopener noreferrer">Jest testing framework</a> has simplified a lot of the complexities behind testing. The secret is a tool called a <a href="https://medium.com/r/?url=https%3A%2F%2Fjestjs.io%2Fdocs%2Fen%2Fmanual-mocks" target="_blank" rel="noopener noreferrer">mock</a>. A mock is effectively a shortened version of a function. Instead of running the function you stub out the result you want. Your code will return what you want instead of running the live code.</p> <p>In other words, you say what an API <em>should</em> return. The mock will bypass the live API and return the data directly. Instead of relying on a date function that changes every 24 hours, you effectively freeze it in place by returning the same date every time.</p> <blockquote> <h5 id="warning">&#x1F6A8; Warning &#x1F6A8;</h5> <p>Mocks are a great tool, but they should be a last resort. If your tests use a significant amount of mocks (or spies or stubs or other testing trick), consider refactoring first. After you have isolated the complexities as much as possible, then it&#x2019;s time to use mocks.</p> </blockquote> <h3 id="jest-a-brief-intro">Jest: A Brief Intro</h3> <p>Jest is a testing framework developed at facebook, it&#x2019;s used most often with React, but it does work independently.</p> <p>Jest offers runtime testing tools. an expect library and system for mocks and spies right out of the box.</p> <p>At it&#x2019;s most basic, a Jest test will look nearly identical to mocha or jasmine or any other framework. In fact, Jest started as a fork of Jasmine.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { double } from <span class="md-code-string">&apos;./double&apos;</span>;

describe(<span class="md-code-string">&apos;Some Test&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should add two number&apos;</span>, () =&gt; {
    expect(double(<span class="md-code-number">1</span>)).toEqual(<span class="md-code-number">2</span>);
  });
});
</code></pre> <p>In this case, <code class="md-code md-code-inline">toEqual</code> is the assertion.</p> <p>That&#x2019;s pretty much all you need for the purposes of this article. There are plenty of extra features that you can read about in the <a href="https://medium.com/r/?url=https%3A%2F%2Fjestjs.io" target="_blank" rel="noopener noreferrer">documentation</a>. You can also look there for installation and configuration. If you want to follow along, check out the <a href="https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fjsmapr1%2Fjest-mock-dive" target="_blank" rel="noopener noreferrer">repo for this article</a>.</p> <h3 id="creating-testable-api-functions">Creating Testable API Functions</h3> <p>Return to your API code. Now that you have your code and you have your test suite all set up, it&#x2019;s time to write tests. As a reminder, you have a piece of code that fetches API data and parses the results.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getRecent</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> fetch(<span class="md-code-string">&apos;/albums&apos;</span>)
    .then(response =&gt; response.json())
    .then(albums =&gt; {
      <span class="md-code-keyword">return</span> albums
        .reverse()
        .slice(<span class="md-code-number">0</span>, <span class="md-code-number">2</span>)
        .map(({title}) =&gt; title);
    })
}
</code></pre> <p>The first step in creating a mock is isolating the pain point. In this case, the problem is the <code class="md-code md-code-inline">fetch</code> block. Specifically this part:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">return</span> fetch(<span class="md-code-string">&apos;/albums&apos;</span>)
    .then(response =&gt; response.json())
</code></pre> <p>The rest of the code isn&#x2019;t so bad. It&#x2019;s just a series of array manipulations.</p> <p>The next step if figuring out what kind of data from the hard part you expect to pass down to the easy part. Again, all you need to do is look at what the live API will return by either hitting it directly or by getting the contract from some other team. In this case, you plan to get the albums of the great doom metal band Sleep. The data you expect to get will look something like this:</p> <pre class="md-code-block"><code class="md-code md-lang-json">[
  {
    &quot;<span class="md-code-attribute">year</span>&quot;: <span class="md-code-value"><span class="md-code-number">1992</span></span>,
    &quot;<span class="md-code-attribute">title</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Holy Mountain&quot;</span>
  </span>},
  {
    &quot;<span class="md-code-attribute">year</span>&quot;: <span class="md-code-value"><span class="md-code-number">1999</span></span>,
    &quot;<span class="md-code-attribute">title</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Jerusalem&quot;</span>
  </span>},
  {
    &quot;<span class="md-code-attribute">year</span>&quot;: <span class="md-code-value"><span class="md-code-number">2014</span></span>,
    &quot;<span class="md-code-attribute">title</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The Clarity&quot;</span>
  </span>},
  {
    &quot;<span class="md-code-attribute">year</span>&quot;: <span class="md-code-value"><span class="md-code-number">2018</span></span>,
    &quot;<span class="md-code-attribute">title</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The Sciences&quot;</span>
  </span>}
]
</code></pre> <p>Now, you should split the function. Pull the hard part away from the easy part. That will make your tests cleaner and easier to mock.</p> <p>As a quick side note, some consider it bad practice to break up your code to make it more testable. I would disagree. Testability tells you something about the complexity of your code. The harder it is to test, the more complex it tends to be. When you are refactoring your code to make it more testable, you just changing the complex to the simple.</p> <p>Since you&#x2019;ve isolate the complex part, the next the step is pulling the <code class="md-code md-code-inline">fetch</code> call out into a separate function. Call the new function<code class="md-code md-code-inline">service</code> and since it now has a separate responsibility go ahead and move it into a new file called <code class="md-code md-code-inline">service.js</code>. To keep things clean, move it to a separate directory called <code class="md-code md-code-inline">api</code> this will be important later when you set up the mock.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">service</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> fetch(<span class="md-code-string">&apos;/albums&apos;</span>)
    .then(response =&gt; response.json())
}
</code></pre> <p>Now you need to import the service and replace the original <code class="md-code md-code-inline">fetch</code> method. Your original function will be a little smaller, but you still are able to perform the exact same actions as your did before:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import service from <span class="md-code-string">&apos;../api/service&apos;</span>;

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getRecent</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> service()
    .then(albums =&gt; {
      <span class="md-code-keyword">return</span> albums
        .reverse()
        .slice(<span class="md-code-number">0</span>, <span class="md-code-number">2</span>)
        .map(({ title }) =&gt; title);
  })
}
</code></pre> <p>At this point, you should start to see an opportunity for a mock. Remember, a mock is just replacing a live piece of code with a simple function that returns the data you expect.</p> <p>In this case, you have a function <code class="md-code md-code-inline">service</code> that returns a <code class="md-code md-code-inline">Promise</code> that returns some sort of array. You happen to know this service hits an API, but that doesn&#x2019;t really matter. It can be loading data from <code class="md-code md-code-inline">localstorage</code> as far as you&#x2019;re concerned.</p> <p>Time to jump into the test. Here&#x2019;s what it&#x2019;ll look like:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { getRecent } from <span class="md-code-string">&apos;./recent&apos;</span>;

describe(<span class="md-code-string">&apos;getRecent&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should get albums&apos;</span>, async () =&gt; {
    <span class="md-code-keyword">const</span> albums = await getRecent();
    <span class="md-code-keyword">const</span> expected = [
      <span class="md-code-string">&apos;The Sciences&apos;</span>,
      <span class="md-code-string">&apos;The Clarity&apos;</span>
    ]
    expect(albums).toEqual(expected);
  })
})
</code></pre> <p>Since <code class="md-code md-code-inline">getRecent</code> returns a promise, you can use <code class="md-code md-code-inline">async/await</code> syntax. This code says, run the <code class="md-code md-code-inline">getRecent</code> function and once it resolves, make sure the albums are as expected.</p> <p>Jest will wait for a promise to resolve if you return. That means you can also write the test like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { getRecent } from <span class="md-code-string">&apos;./recent&apos;</span>;

describe(<span class="md-code-string">&apos;getRecent&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should get albums&apos;</span>, () =&gt; {
    <span class="md-code-keyword">return</span> getRecent()
      .then(albums =&gt; {
        <span class="md-code-keyword">const</span> expected = [
          <span class="md-code-string">&apos;The Sciences&apos;</span>,
          <span class="md-code-string">&apos;The Clarity&apos;</span>
        ]
        expect(albums).toEqual(expected);
      })
  })
})
</code></pre> <p>Either way, you still need to account for the service. Currently, it will still try (and probably fail) to hit a live endpoint.</p> <p>Now, it&#x2019;s time to start mocking the results.</p> <h3 id="mocking-an-api-result">Mocking an API Result</h3> <p>There are multiple ways to mock data, but the easiest is by creating a manual mock at the same level as the code you need to bypass.</p> <p>In practical terms, you are going to make a file of the same name that returns data that you want instead of executing a function to get that data.</p> <p>Start by making a directory called <code class="md-code md-code-inline">__mocks__</code> in the <em>same</em> directory as <code class="md-code md-code-inline">service.js</code> Suppose you had a directory called <code class="md-code md-code-inline">api</code> that contained <code class="md-code md-code-inline">services.js</code>, you&#x2019;d add your <code class="md-code md-code-inline">__mocks__</code> in the same <code class="md-code md-code-inline">api</code> directory like this:</p> <pre class="md-code-block"><code class="md-code">| api
  | __mocks__
    | service.js
  | service.js
</code></pre> <p>Inside <code class="md-code md-code-inline">__mocks__/service.js</code> create a function with the same name, but that returns the data you want.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> albums = [
  {
    year: <span class="md-code-number">1992</span>,
    title: <span class="md-code-string">&apos;Holy Mountain&apos;</span>
  },
  {
    year: <span class="md-code-number">1999</span>,
    title: <span class="md-code-string">&apos;Jerusalem&apos;</span>
  },
  {
    year: <span class="md-code-number">2014</span>,
    title: <span class="md-code-string">&apos;The Clarity&apos;</span>
  },
  {
    year: <span class="md-code-number">2018</span>,
    title: <span class="md-code-string">&apos;The Sciences&apos;</span>
  },
];

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">service</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> Promise.resolve(albums)
}
</code></pre> <p>Just as with the actual <code class="md-code md-code-inline">service</code> function. This one returns a <code class="md-code md-code-inline">Promise</code> but unlike the original function, this one has the data hard coded. It will never change.</p> <p>Now that you&#x2019;ve set up your mock, you need to alert your test that you want to use the manual mock instead of the real function. To do that, you need to use <code class="md-code md-code-inline">jest.mock(path)</code> where the <code class="md-code md-code-inline">path</code> is the location of the file you want to mock.</p> <p>Suppose you had a file structure like this:</p> <pre class="md-code-block"><code class="md-code">| albums
  | recent.js
  | recent.spec.js
| api
  | __mocks__
    | service.js
  | service.js
</code></pre> <p>In your test, add the line <code class="md-code md-code-inline">jest.mock(&apos;../api/service&apos;)</code>. Notice, you are not adding the path to the <code class="md-code md-code-inline">__mocks__</code> directory, you are using the same path as if you were importing the function. Jest will find the mock for you. You are using the same path as you would in <code class="md-code md-code-inline">recent.js</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { getRecent } from <span class="md-code-string">&apos;./recent&apos;</span>;

jest.mock(<span class="md-code-string">&apos;../api/service&apos;</span>);

describe(<span class="md-code-string">&apos;recent&apos;</span>, () =&gt; {
  it(<span class="md-code-string">&apos;should get albums&apos;</span>, async () =&gt; {
    <span class="md-code-keyword">const</span> albums = await getRecent();
    <span class="md-code-keyword">const</span> expected = [
      <span class="md-code-string">&apos;The Sciences&apos;</span>,
      <span class="md-code-string">&apos;The Clarity&apos;</span>
    ]
    expect(albums).toEqual(expected);
  })
})
</code></pre> <p>Now, you are not hitting a live API. You are hitting an internal simulation. And it only takes one line of code. You don&#x2019;t need network connectivity. You don&#x2019;t need to worry about results changing. You don&#x2019;t need to spin up a separate service. Everything is happening internally.</p> <h3 id="what-s-next">What&#x2019;s next?</h3> <p>Mocking API data is one of the best uses of mocks. Nearly all JavaScript projects need to be able to access remote data. However, mocks can do a lot more. They can also deal with complicated side effects such as date time or DOM manipulations. In my next article, I&#x2019;ll show you how to mock out <code class="md-code md-code-inline">moment</code> and other libraries that return data that changes depending on the day or even the location of the test.</p></div>
